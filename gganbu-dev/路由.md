# 路由

## 211030

最终方案 **生成配置文件** + **集中处理路由**

## 211029

### 大前提

框架早期版本，将作为 Server 不扩展前端开发。为了保持原生的开发体验，优先解决的是 将常用配置代码 尽可能自动化，生成对应文件。  
而在整个运行过程中，依旧会执行 生成文件中的内容。  
在之后的版本，才会加入 Runtinme 运行时 配合前端一体化。

### 目的

起初的目的，通过脚本自动化生成，解决 routes 和 controllers 之间的某些联系。  
比如按照规定 controllers 中含有 getInfo，那么对应路由，必须要有 一条路由，路径为 getInfo 且方法为 GET。  
无论是根据 controllers 生成 routes 还是 routes 生成 controllers 都是可行的。  
那么将会存在三个要解决的问题。

- 根据 controllers 生成 routes 无法区别 **请求方法**
- 解决 **路由中间件** 的配置问题。
- 为 **一体化** 自动配置 **api** 打下基础

第三个问题，其实和第二个问题接近，解决了第二个 其实就解决了 第三个问题。

### midway 的借鉴

在 **midway** 中采用的是，根据特定目录下 已有的异步函数 生成 api。 与目前采用方案相同。  
其中，**midway** 规范 异步函数 是否带参数 来 区别最终的请求方法。 猜想可能是因为 POST 通常在请求体上传信息，很好解决了第三个问题。  
而我们，会直接对文件导出的对象 进行 key 值的判断，如果以 get 开始，默认为 GET 方法。其余为 post 方法。

和 **midway**的区别，**midway** 已经是封装一层，不含 http 的请求上下文内容，函数返回值 即是请求返回内容。

而我们将保留框架的原生开发体验，不进行封装，遵循大前提。

同时，针对于 第二个问题，我在 **midway** 中，也发现了解决方案。

> 在 2.0 版本中，Midway Hooks 支持三种形式的中间件，用来覆盖不同的使用诉求。  
> ● 全局，对所有 Api 调用都生效  
> ● 文件，对文件内部所有 Api 生效  
> ● 函数，仅对该 Api 函数生效

而我们只会提供，两种形式的，一种是函数级别，也就是路由级别的，其次就是 全局级别的。

**midway** 会使用 **wrapControllers** 重新装饰一层导出异步函数，操作也可行。学到了。
