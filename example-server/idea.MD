# 用于演示想法。 server 实际不可运行。不可用

## 大前提，

**解析 service**

- service 的核心 是 **模块或者业务模型**。
- DB 只是存储存储数据的一种方式，所以也需要隔离一下。
  - 而且大部分时候，不需要直接利用 model 来操作数据库。请避免又臭又长的代码。
  - 基于以上一点，可以生成比较通用的数据库基础操作。
- service 的职责，主要是 **业务逻辑** 和 **数据库表的维护**，
  - 业务逻辑比如一个流程，下单流程，要先验证，再生成订单，再更新销量等等。 这是按功能分。
    - 这部分 以功能为单位 完全可以放到 bff，或者目前更适合 bff 因为按目前现状，写 bff 的人更早接触更熟悉功能流程。
  - 其次，数据维护，有时候为了可扩展，互不影响，会进行**数据库设计分表**，
    - 比如，常见的，产品信息获取 需要带着规格信息。。
      - 那这个时候可以重写 getFoods 变成 getFoodsWithSpecs (带规格信息) 至于要不要保留基础的数据库操作 getFoods，看场景。
        - 不保留的话，重写 getFoods 保留的话，新写 getFoodsWithSpecs 注意，这里的查询参数 还是 getFoods 的查询参数
    - 再比如，上面的下单流程， 订单表 分为 订单产品表，订单信息表。 但这个时候 这两者 最好是对外保持一个整体。
      - 也就是 一个 createOrder 完成 订单信息表 createOrder 和 订单产品表 createGoods，两个表的操作。
- service 在 维护**数据 和 业务模型**的时候 尽量不报错。而是返回数据。 （**这点比较理想，可以跳过**）
  - 报错是 http 的事情。
    - 因为 service 不仅仅 对外暴露服务，服务之间还可以互相调用。 比如统计 需要获取详细的订单信息，产品信息，很明显的 一个属于订单服务，产品服务
      - 只需要 在统计服务中，调用 相应的 getOrders getFoods ，再重新整合。
  - 一个 service 需要尽可能地保持干净，通过 http 访问 service，如果没数据，只能是 http 告诉我没有数据，需要报个 404。
    - 所以在 某些项目框架中，会单独再封装 http 作为一层 叫做 gateway。
  - 再比如 更新操作，我不知道 service 有没有更新， 更新成功，返回更新后的数据，不成功，返回空，告诉我更新失败的还是 http，报个 403。

## 优劣势分析

### 优势

- 快，所有的服务 只是在 根据 **业务模型** 去 **整合** 数据层信息。
  - 功能流程开发 可以放入 bff。。。 并行开发，不用等待。
    - 等到 bff 一直在重复某个部分， 需要重新提升为 一个接口服务。
    - 比如一开始 产品信息，只提供两个基础接口 getFoods getSpecs，bff 自己整合这产品基础信息和规格信息，结果每个 bff 在获取数据的时候都需要这么干。
      - 这时候就需要抽象 提升 到服务层。
  - 所有的基础数据操作自动生成，写好 schema，可以以最快的速度先 提供基础服务接口。
- 可复用性高
  - 最小单位，永远是**单表的操作**。而且是固定的。
    - 目前开发的反例，是在 service 到处用 model 直接操作数据库。很不建议这么做。
- 协同性更好
  - 完全可以根据业务场景 安排多人同时开发。
    - 比如 **产品信息** 和 **产品上下架信息**
      - 产品信息 数据库本身可以不包括上下架信息 ，只需要 一个接口 **getFoods**，只有具体业务用到上下架信息，比如 pos 外卖
        - pos 或外卖 场景，需要返回 产品信息 + 上下架信息。
          - 通过加中间表。 **pos 设置表** **外卖设置表**。
          - 自动生成中间表 操作，getPosFoods getTakeawayFoods // 注意这是 中间表信息
          - 写出接口 **getFoodsWithPosSetting** **getFoodsWithTakeawaySetting**
            - getFoodsWithPosSetting = compose(getFoods,getPosFoods)
            - getFoodsWithTakeawaySetting = compose(getFoods,getTakeawayFoods)
  - 协同性好的另一层意思可以扩理解为 **服务自治**，可以 并行 开发
    - 比如 pos 所有的相关的服务接口完全可以独立管理独立部署，只不过 **不可避免** 地需要一些**中间表**来补充信息。
      - 比如上面例子，pos 设置表 就是一个**中间表**， 但是如果一开始约定全部集中管理，那没必要出现 pos 设置表了，
      - 在 产品表下，新建一个对象，包括 pos 设置，他不香吗？ 避免了 **多表操作** 的麻烦，也同时充分利用了 mongodb 的优势。
        - 这也是，我一开始一直在问的，项目要做成什么样，是餐厅是主体还是以服务为主体，**业务模型** 直接涉及到 底层结构设计。
          - 如果是餐厅为主体，现在的模式，全部由李永华管理，没问题。但是必然会出现 串行，前后端互相等的情况。
            - 以餐厅为主体，还需要抽象出，餐厅基本信息，外卖服务使用信息
          - 如果以服务为核心，pos 或者 未来的会员、营销、拼团，完全可以**服务自治**。基础信息全在在智慧餐厅了，只要多加几个**关联表** 来补充信息。
            - 而整个 云平台后台 老板端（现在应该都没有 pos 的订单汇总信息，距离老板端能查看所有订阅的服务信息，还须努力） 将会是多个服务的一个在一起的体现，也不会只有一个人来完成。
- **可维护性** 也是最重要一点
  - 数据层更可控。不会出现一个表，会在多个地方被直接操作。
    - 举个例子，经常需要有 数据状态 **deleted** 属性标记 被删除或者无效数据。
      - 如果 service 直接操作数据库，将会在很多地方 出现 {$match:{status:{$ne:'deleted'}}}，万一有一个地方没写呢。
        - 或者 这个功能是后来加上的，那怎么办？全局搜索添加吗？？？ wms 产品规格信息，就碰到这个问题。
          - wms 的 sku 上下架功能，需要 约等于 删除。 只要下架，说明这个产品规格无效，在任何地方不该出现 这个 sku 的信息。
          - 而这个功能是后来加的。
      - 可以在 service 和 数据存储层中间， 也就是 自动生成的数据库基础操作中，直接重写 再来一个 状态筛选。万事大吉。
    - 再举个例子，会在代码经常看到 产品 lookup 分类 接着 lookup 规格，这种多表 lookup 的操作
      - 这有两个问题，一个是 **重复代码太多，不易维护**。 一个是 **多表操作的性能问题**
      - 如果有索引，lookup 会利用 索引 查询。但是不能忽略聚合过程中，**内存占用** 和 **排序** 带来的 **性能隐患** 和 **速度明显降低**。
        - B 端之前 经常 OOM 就是这个原因。
        - 其中内存占用 经常是容易被忽视的问题，虽然可以通过 **project** 来降低 聚合过程 每个 stage 的数据量，但这基本是问题产生了 才会去优化。
          - 另外，project 过滤数据，也可以 肉眼可见的 提升查询速度。
        - 还有一个隐患，我不是很确认，aggragate 的 match 和 sort 只会 利用一次索引，后面的 state 再出现 match 和 sort 不会再利用索引。

### 劣势

- 多余
  - 基础数据操作显得很多余，甚至很别扭
  - 因为直接操作数据库带来的方便性和快不言而喻。。 如果项目是我一个人写，我肯定也是会直接上来就 数据库 model 操作，
- 单表操作的基础操作提供的功能有限，不便捷，比如
  - populate，就很舒服，套餐数据结构有四层，产品卡在中间 populate 一下产品数据。
    - 不过这好像也是我第一次用 populate，我通常都是 聚合 lookup。
  - 再比如，怎么提供 字段 数组的 push 操作？和 字段的 unset 操作。？ 或者是某个数组字段内 根据 匹配到的 index 来更新。？
    - 暂时没想到很好的解决方案。 lyz 也因为这个强烈反对过，为什么不直接使用数据库提供的方便操作，数据库提供了那么多便捷 api，不是浪费?。
  - 再比如，比如如何 去 解决，返回字段多余的问题，有时候需要全部信息 有时候只需要返回几个字段。
    - 这种问题，可以用 util dbservice 迂回解决。但又是一个很别扭的地方。
- 服务自治的问题。这个不是劣势，因为项目还是可以集中部署的。 但是相对上面的优势，提一下。
  - 对立面就是集中管理，因为要达到服务自治，不可避免地 **要创立中间表**。 多表带来的麻烦，不必要开支。需要和 集中管理开发的便捷性但是会串行工作 做一个平衡

## 其他

以下几点，都是在项目开发时候需要考虑东西，比较通用

- **业务模型** 理解的缺失，
  - 在上述这么多过程中，一个很重要的基础是，**业务模型** 需要先理解到位。
    - 这可能直接涉及到，底层数据库的结构。
      - 尽管 加表 加字段 都是可以解决问题的，但是 从源头治理，产生的效果肯定更好，这也是为什么数据库字段设计好了，整个项目开发就很方便。
    - 以下 有几个 会影响到 **整个业务模型的** 理解。
      - 业务发展全貌的缺失
        - 如果 一个项目阶段，A+B+C+未来 但是开发这边只是得知了 A, 结果设计架构非常局限， 要做 B，C 的时候，发现要推翻原来的思路要大改，
      - 产品只有原型图没有功能列表，难以在脑海中理解并拼凑业务面貌。
- 角色的担当
  - 其实很多场景，需要把控好前后端的平衡，这种需要负责人 在对**业务模型**理解后 靠经验去分配任务。
    - 比如下单流程，到底需不需要 按功能 拆开，由 bff 自己调用。
      - 假设，pos 需要 更新桌台信息，外卖明显不需要？？
        - 那是不是 server 能做的 只是 一部分下单流程。最后的 更新桌台信息，只能放开给 bff，要不然 在 server 就会出现 ifelse
